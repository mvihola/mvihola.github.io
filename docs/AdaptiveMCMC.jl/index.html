<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · AdaptiveMCMC.jl Documentation</title><meta name="title" content="Introduction · AdaptiveMCMC.jl Documentation"/><meta property="og:title" content="Introduction · AdaptiveMCMC.jl Documentation"/><meta property="twitter:title" content="Introduction · AdaptiveMCMC.jl Documentation"/><meta name="description" content="Documentation for AdaptiveMCMC.jl Documentation."/><meta property="og:description" content="Documentation for AdaptiveMCMC.jl Documentation."/><meta property="twitter:description" content="Documentation for AdaptiveMCMC.jl Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>AdaptiveMCMC.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Sampling-from-log-posteriors"><span>Sampling from log-posteriors</span></a></li><li><a class="tocitem" href="#With-adaptive-parallel-tempering"><span>With adaptive parallel tempering</span></a></li><li><a class="tocitem" href="#Restarting-simulation"><span>Restarting simulation</span></a></li><li><a class="tocitem" href="#Using-individual-modules-in-a-custom-setting"><span>Using individual modules in a custom setting</span></a></li></ul></li><li><a class="tocitem" href="rwm/">Random walk sampler state</a></li><li><a class="tocitem" href="adapt/">Adaptation state</a></li><li><a class="tocitem" href="step/">Step sizes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mvihola/AdaptiveMCMC.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mvihola/AdaptiveMCMC.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>This package provides implementations of some general-purpose random-walk based adaptive MCMC algorithms, including the following:</p><ul><li>Adaptive Metropolis, proposal covariance adaptation, (<a href="https://projecteuclid.org/euclid.bj/1080222083">Haario, Saksman and Tamminen, 2001</a>, and <a href="http://dx.doi.org/10.1214/105051606000000286">Andrieu and Moulines, 2006</a>)</li><li>Adaptive scaling Metropolis, acceptance rate adaptation for scale (e.g. as in <a href="https://doi.org/10.1007/s11222-008-9110-y">Andrieu and Thoms, 2008</a>, and <a href="https://projecteuclid.org/euclid.bj/1265984706">Atchadé and Fort, 2010</a>)</li><li>Robust Adaptive Metropolis, acceptance rate adaptation for shape <a href="http://dx.doi.org/10.1007/s11222-011-9269-5">(Vihola, 2012)</a></li><li>Adaptive Parallel Tempering, acceptance rate adaptation for temperature levels <a href="http://dx.doi.org/10.1080/10618600.2013.778779">(Miasojedow, Moulines and Vihola, 2013)</a></li></ul><p>The aim of the package is to provide a simple and modular general-purpose implementation, which may be easily used to sample from a log-target density, but also used in a variety of custom settings.</p><p>See also <a href="https://github.com/mvihola/AdaptiveParticleMCMC.jl">AdaptiveParticleMCMC.jl</a> which uses this package with <a href="https://github.com/awllee/SequentialMonteCarlo.jl">SequentialMonteCarlo.jl</a> for adaptive particle MCMC.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>To get the latest registered version:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;AdaptiveMCMC&quot;)</code></pre><p>To install the latest development version:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(url=&quot;https://github.com/mvihola/AdaptiveMCMC.jl&quot;)</code></pre><h2 id="Sampling-from-log-posteriors"><a class="docs-heading-anchor" href="#Sampling-from-log-posteriors">Sampling from log-posteriors</a><a id="Sampling-from-log-posteriors-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-from-log-posteriors" title="Permalink"></a></h2><p>The package provides an easy-to-use adaptive random-walk Metropolis sampler, which samples (in principle) from any probability distribution <span>$p$</span>, whose log-density values can be evaluated point-wise.</p><pre><code class="language-julia hljs"># Load the package
using AdaptiveMCMC

# Define a function which returns log-density values:
log_p(x) = -.5*sum(x.^2)

# Run 10k iterations of the Adaptive Metropolis:
out = adaptive_rwm(zeros(2), log_p, 10_000; algorithm=:am)

# Calculate &#39;95% credible intervals&#39;:
using Statistics
mapslices(x-&gt;&quot;$(mean(x)) ± $(1.96std(x))&quot;, out.X, dims=2)</code></pre><p>See <a href="adapt/#Adaptation-state">Adaptation state</a> for explanation of the different <code>algorithm</code> options:</p><ul><li><code>:am</code> = <code>AdaptiveMetropolis</code></li><li><code>:ram</code> = <code>RobustAdaptiveMetropolis</code></li><li><code>:asm</code> = <code>AdaptiveScalingMetropolis</code></li><li><code>:aswam</code> = <code>AdaptiveScalingWithinAdaptiveMetropolis</code></li></ul><p>There are a number of other optional keyword arguments, too:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AdaptiveMCMC.adaptive_rwm" href="#AdaptiveMCMC.adaptive_rwm"><code>AdaptiveMCMC.adaptive_rwm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">out = adaptive_rwm(x0, log_p, n; kwargs)</code></pre><p>Generic adaptive random walk Metropolis algorithm from initial state vector <code>x0</code> targetting log probability density <code>log_p</code> run for <code>n</code> iterations, including adaptive parallel tempering.</p><p><strong>Arguments</strong></p><ul><li><code>x0::Vector{&lt;:AbstractFloat}</code>: The initial state vector</li><li><code>log_p::Function</code>: Function that returns log probability density values                    (up to an additive constant) for any state vector.</li><li><code>n::Int</code>: Total number of iterations</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>algorithm::Symbol</code>: The random walk adaptation algorithm; current choices are <code>:ram</code> (default), <code>:am</code>, <code>:asm</code>, <code>:aswam</code> and <code>:rwm</code>. (Alternatively, if algorithm is a vector of AdaptState, then this will be used as an initial state for adaptation.)</li><li><code>b::Int</code>: Burn-in length: <code>b</code>:th sample is the first saved sample. Default <code>⌊n/5⌋</code></li><li><code>thin::Int</code>: Thinning factor; only every <code>thin</code>:th sample is stored; default <code>1</code></li><li><code>fulladapt::Bool</code>: Whether to adapt after burn-in; default <code>true</code></li><li><code>Sp</code>: Saved adaptive state from output to restart MCMC; default <code>nothing</code></li><li><code>Rp</code>: Saved rng state from output to restart MCMC; default <code>nothing</code></li><li><code>indp::Int</code>: Index of saved adaptive state to restart MCMC; default <code>0</code></li><li><code>rng::AbstractRNG</code>: Random number generator; default <code>Random.GLOBAL_RNG</code></li><li><code>q::Function</code>: Zero-mean symmetric proposal generator (with arguments <code>x</code> and <code>rng</code>);  default <code>q=randn!(x, rng)</code></li><li><code>L::Int</code>: Number of parallel tempering levels</li><li><code>acc_sw::AbstractFloat</code>: Desired acceptance rate between level swaps; default <code>0.234</code></li><li><code>all_levels::Bool</code>: Whether to store output of all levels; default <code>false</code></li><li><code>log_pr::Function</code>: Log-prior density function; default <code>log_pr(x) = 0.0</code>.</li><li><code>swaps::Symbol</code>: Swap strategy, one of:  <code>:single</code> (default, single randomly picked swap)  <code>:randperm</code> (swap in random order)  <code>:sweep</code> (up- or downward sweep, picked at random)  <code>:nonrev</code> (alternate even/odd sites as in Syed, Bouchard-Côté, Deligiannidis,  Doucet, 	arXiv:1905.02939)</li><li><code>progress::Union{Bool,Progress}</code>: Whether a progress meter is shown; default <code>false</code></li></ul><p>Note that if <code>log_pr</code> is supplied, then <code>log_p(x)</code> is regarded as the log-likelihood (or, equivalently, log-target is <code>log_p(x) + log_pr(x)</code>). Tempering is only applied to <code>log_p</code>, not to <code>log_pr</code>.</p><p>The output <code>out.X contains the simulated samples (column vectors).</code>out.allX[k]<code>for</code>k&gt;=2` contain higher temperature auxiliary chains (if requested)</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">log_p(x) = -.5*sum(x.^2)
o = adaptive_rwm(zeros(2), log_p, 10_000; algorithm=:am)
using MCMCChains, StatsPlots # Assuming MCMCChains &amp; StatsPlots are installed...
c = Chains(o.X[1]&#39;, start=o.params.b, thin=o.params.thin); plot(c)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mvihola/AdaptiveMCMC.jl/blob/0b068a3705698bc84b123bbdd06b0dc019ada5da/src/adaptive_rwm.jl#L120-L173">source</a></section></article><h2 id="With-adaptive-parallel-tempering"><a class="docs-heading-anchor" href="#With-adaptive-parallel-tempering">With adaptive parallel tempering</a><a id="With-adaptive-parallel-tempering-1"></a><a class="docs-heading-anchor-permalink" href="#With-adaptive-parallel-tempering" title="Permalink"></a></h2><p>If the keyword argument <code>L</code> is greater than one, then the adaptive parallel tempering algorithm (APT) of <a href="http://dx.doi.org/10.1080/10618600.2013.778779">Miasojedow, Moulines &amp; Vihola (2013)</a> is used. This can greatly improve mixing with multimodal distributions.</p><p>Here is a simple multimodal distribution sampled with normal adaptive random walk Metropolis, and with APT:</p><pre><code class="language-julia hljs"># Multimodal target of dimension d.
function multimodalTarget(d::Int, sigma2=0.1^2, sigman=sigma2)
    # The means of mixtures
    m = [2.18 5.76; 3.25 3.47; 5.41 2.65; 4.93 1.50; 8.67 9.59;
         1.70 0.50; 2.70 7.88; 1.83 0.09; 4.24 8.48; 4.59 5.60;
         4.98 3.70; 2.26 0.31; 8.41 1.68; 6.91 5.81; 1.14 2.39;
         5.54 6.86; 3.93 8.82; 6.87 5.40; 8.33 9.50; 1.69 8.11]&#39;
    n_m = size(m,2)
    @assert d&gt;=2 &quot;Dimension should be &gt;= 2&quot;
    let m=m, n_m=size(m,2), d=d
        function log_p(x::Vector{Float64})
            l_dens = -0.5*(mapslices(sum, (m.-x[1:2]).^2, dims=1)/sigma2)
            if d&gt;2
                l_dens .-= 0.5*mapslices(sum, x[3:d].^2, dims=1)/sigman
            end
            l_max = maximum(l_dens) # Prevent underflow by log-sum trick
            l_max + log(sum(exp.(l_dens.-l_max)))
        end
    end
end

using AdaptiveMCMC
n = 100_000; L = 2
rwm = adaptive_rwm(zeros(2), multimodalTarget(2), n; thin=10)
apt = adaptive_rwm(zeros(2), multimodalTarget(2), div(n,L); L = L, thin=10)

# Assuming you have &#39;Plots&#39; installed:
using Plots
plot(scatter(rwm.X[1,:], rwm.X[2,:], title=&quot;w/o tempering&quot;, legend=:none),
scatter(apt.X[1,:], apt.X[2,:], title=&quot;w/ tempering&quot;, legend=:none), layout=(1,2))</code></pre><p>What the APT is actually based on? Parallel tempering is a MCMC algorithm which samples from a product density proporitional to:</p><p class="math-container">\[\prod_{i=1}^L p^{\beta(i)}(x^{(i)}),\]</p><p>where (the &#39;inverse temperatures&#39;) <span>$1 = \beta(1) &gt; \beta(2) &gt; \cdots &gt; \beta(L) &gt; 0$</span>.</p><p>In the end, the &#39;first level&#39; is of interest (and samples of the first level are usually used for estimation), whereas the tempered levels <span>$i=2,\ldots,L$</span> are auxiliary, which help the sampler to move between modes of a multi-modal target. The easier moving is because the tempered densities <span>$p^{\beta(i)}$</span> are &#39;flatter&#39; than <span>$p$</span> for any <span>$\beta(i)&lt;1$</span>.</p><p>The sampler consists of two types of MCMC moves:</p><ul><li>Independent adaptive random-walk Metropolis moves on individual levels <span>$i$</span>, targetting tempered densities <span>$p^{\beta(i)}$</span>. </li><li>Switch moves, where swaps of adjacent levels <span>$x^{(i)} \leftrightarrow x^{(i+1)}$</span> are proposed, and the moves are accepted with (Metropolis-Hastings) probability <span>$\min\big\{1, \frac{p^{\beta(i)-\beta(i+1)}(x^{(i+1)})}{p^{\beta(i)-\beta(i+1)}(x^{(i)})}\big\}$</span>.</li></ul><p>In the APT, each random walk sampler for each individual level is adapted totally independently, following exactly the same mechanism as before. Additionally, the APT adapts the inverse temperatures <span>$\beta(2),\ldots,\beta(L)$</span>, in order to reach the average switch probability <span>$0.234$</span>. More precisely, adaptation mechanism tunes the parameters <span>$\rho^{(i)}$</span>, which determine</p><p class="math-container">\[\frac{1}{\beta^{(i)}} = \frac{1}{\beta^{(i-1)}} + e^{\rho^{(i)}},\]</p><p>and the adaptation is similar to <a href="adapt/#Adaptive-scaling-Metropolis">Adaptive scaling Metropolis</a>: if swap <span>$x^{(i-1)}\leftrightarrow x^{(i)}$</span> is proposed the <span>$k$</span>:th time, the parameter is updated as follows:</p><p class="math-container">\[\rho_k^{(i)} = \rho_{k-1}^{(i)} + \gamma_k (\alpha_k^{(\text{swap }i)} - \alpha_*),\]</p><p>where <span>$\alpha_k^{(\text{swap }i)}$</span> is the swap probability.</p><h2 id="Restarting-simulation"><a class="docs-heading-anchor" href="#Restarting-simulation">Restarting simulation</a><a id="Restarting-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Restarting-simulation" title="Permalink"></a></h2><p>Simulation can be restarted, or continued after one simulation. Here is an example:</p><pre><code class="language-julia hljs">using AdaptiveMCMC, Random
log_p(x) = -.5*sum(x.^2)
Random.seed!(12345)
# Simulate 200 iterations first:
out = adaptive_rwm(zeros(2), log_p, 200)
# Simulate 100 iterations more:
out2 = adaptive_rwm(out.X[:,end], log_p, 100; Sp=out.S, Rp=out.R, indp=200)
# This results in exactly the same output as simulating 300 samples in one go:
Random.seed!(12345)
out2_ = adaptive_rwm(zeros(2), log_p, 300)</code></pre><h2 id="Using-individual-modules-in-a-custom-setting"><a class="docs-heading-anchor" href="#Using-individual-modules-in-a-custom-setting">Using individual modules in a custom setting</a><a id="Using-individual-modules-in-a-custom-setting-1"></a><a class="docs-heading-anchor-permalink" href="#Using-individual-modules-in-a-custom-setting" title="Permalink"></a></h2><p>In many cases, the simple samplers provided by <code>adaptive_rwm</code> are not sufficient, but a custmised sampler is necessary. For instance:</p><ul><li>Adaptative sampler is used only for certain parameters, whilst others are updated by another MCMC scheme, such as with Gibbs moves.</li><li>The sampler state is large, and simulations cannot be saved in memory.</li></ul><p>The package provides simple building blocks which allow such custom scenarios. Here is a simple example how the individual components can be used:</p><pre><code class="language-julia hljs">using AdaptiveMCMC

# Sampler in R^d
function mySampler(log_p, n, x0)

    # Initialise random walk sampler state: r.x current state, r.y proposal
    r = RWMState(x0)

    # Initialise Adaptive Metropolis state (with default parameters)
    s = AdaptiveMetropolis(x0)
    # Other adaptations are: AdaptiveScalingMetropolis,
    # AdaptiveScalingWithinAdaptiveMetropolis, and RobustAdaptiveMetropolis

    X = zeros(eltype(x0), length(x0), n) # Allocate output storage
    p_x = log_p(r.x)                     # = log_p(x0); the initial log target
    for k = 1:n

        # Draw new proposal r.x -&gt; r.y:
        draw!(r, s)

        p_y = log_p(r.y)                      # Calculate log target at proposal
        alpha = min(one(p_x), exp(p_y - p_x)) # The Metropolis acceptance probability

        if rand() &lt;= alpha
            p_x = p_y

            # This &#39;accepts&#39;, or interchanges r.x &lt;-&gt; r.y:
            # (NB: do not do r.x = r.y; these are (pointers to) vectors!)
            accept!(r)
        end

        # Do the adaptation update:
        adapt!(s, r, alpha, k)

        X[:,k] = r.x   # Save the current sample
     end
    X
end

# Standard normal target for testing
normal_log_p(x) = -mapreduce(e-&gt;e*e, +, x)/2

# Run 1M iterations of the sampler targetting 30d standard Normal:
X = mySampler(normal_log_p, 1_000_000, zeros(30))</code></pre><p>See <a href="rwm/#Random-walk-sampler-state">Random-walk sampler state</a> and <a href="adapt/#Adaptation-state">Adaptation state</a> for more details about these components.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="rwm/">Random walk sampler state »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 19 January 2024 18:35">Friday 19 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
